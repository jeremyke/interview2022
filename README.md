## 一、语法/算法

#### 1. PHP基础语法


opcache原理、php生命周期、php-fpm中php的三种运行模式、设计模式

#### 2. Golang基础语法

#### 3. 常见算法

#### 4. 刷题



## 二、服务器

#### 1. 计算机基本原理

#### 2. Shell

#### 3. 常用命令

#### 4. K8s & Docker

## 三、网络编程

#### 1. Nginx


2ml、手撕tcp的三次握手和四次挥手的图

## 四、数据库

### 1. Mysql

#### 1.1 索引

1.1.1 B-Tree、B+Tree以及MySQL的B+Tree的区别？

B树的特点：

（1）所有键值分布在整个树中
（2）任何关键字出现且只出现在一个节点中
（3）搜索有可能在非叶子节点结束
（4）在关键字全集内做一次查找，性能逼近二分查找算法

B+Tree的特点：

（1）所有关键字存储在叶子节点，非叶子节点不存储真正的data
（2）为所有叶子节点增加了一个链指针(普通B+Tree增加的是单向指针，MySQL增加的是双向指针)

为什么mysql的索引使用B+树而不是B树呢？

（1）B+树更适合外部存储(一般指磁盘存储),由于内节点(非叶子节点)不存储data，所以一个节点可以存储更多的内节点，每个节点能索引的范围更大更精确。也就是说使用B+树单次磁盘IO的信息量相比较B树更大，IO效率更高。

（2）mysql是关系型数据库，经常会按照区间来访问某个索引列，B+树的叶子节点间按顺序建立了链指针，加强了区间访问性，所以B+树对索引列上的区间范围查询很友好。而B树每个节点的key和data在一起，无法进行区间查找。


1.1.2 InnoDB B+Tree是怎么产生的？

磁盘中数据的存储：

![image](resource/WX20220310-232448@2x.png)

聚簇索引的结构：

![image](resource/WX20220310-234607@2x.png)


联合索引的结构：

![image](resource/WX20220310-235603@2x.png)

叶子节点存放主键ID,再根据主键ID去聚簇索引里面查数据（回表）。

InnoDB的一棵B+树可以存放多少行数据？    
根节点最大数据条数：(16K)16384/14(bigint8个字节+指针6个字节) = 1170个单元
叶子节点：（16K）/1k(假设每条数据1K) = 16条数据
2层B+树：1170*16
3层：1170*1170*16


1.1.3 范围查找

聚簇索引的范围查找用到了索引，非聚簇索引的范围查找不一定用到索引，尽量给到精确范围。

1.1.4 最左前缀原则

覆盖索引：查询非聚簇索引的叶子节点上存放着查询的字段。

1.1.5 索引扫描底层原理

查询一个非聚簇索引的字段时，可以通过走非聚簇索引，比全表扫描聚簇索引块，业务非聚簇索引存的是主键，一页能存更多数据，IO次数更少。

1.1.6 Order By导致索引失效

order by联合索引查询*，有两种查询途径。a.走联合索引，需要对每条数据回表,b.全表扫描，内存中排序，不需要回表。实际会走全表扫描！如果查询的是联合索引的某个值，不回表。会走联合索引。

1.1.7 类型混用引起索引失效

mysql会将数值字符转为数值；非数值字符转为0。对查询的字段转换类型或者运算，均会引起索引失效。

1.1.8 索引下推

索引下推（index condition pushdown ）简称ICP，在Mysql5.6的版本上推出，用于优化查询。
在不使用ICP的情况下，在使用非主键索引（又叫普通索引或者二级索引）进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。
在使用ICP的情况下，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。
索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。

#### 1.2 引擎

1.2.1 MyISAM和InnoDB的区别？

（1）InnoDB支持事务，但是MyISAM不支持事务。
（2）InnoDB支持外键，但是MyISAM不支持外键。
（3）InnoDB是聚簇索引，必须要有主键，通过辅助索引需要查询两次，先查询到主键，再通过主键索引查询到数据，且主键不能过大，主键过大，索引也会很大；MyISAM是非聚簇索引，数据和索引是分离的，索引保存的是数据文件的指针。
（4）InnoDB不保存表的具体行数，count(*)需要全表扫描；MyISAM会保存表的行数，查询count(*)会很快。
（5）InnoDB最小粒度是行锁，MyISAM是表锁。

#### 1.3 数据库设计

1.3.1 字段类型的优先级

整形 > data,time > enum char > varchar > blob, text

选用字段长度最小、优先使用定长形、数值型字段避免使用“zerofill”

1.3.2 可以选整形就不选字符串

1.3.3 字段长度够用就好，不要太多

1.3.4 尽量避免使用NULL

1.3.5 存储空间要求不大但在速度上有要求，尽量使用char,反之用varchar

#### 1.4 事务

1.4.1 事务的基本特性
原子性：一个事务中的所以操作要么全部成功要么全部失败

一致性：数据库总能从一个一致性的状态转换到另一个一致性的状态。比如A向B转账，中间系统崩溃，事务未提交，需改不会保存到数据库。

隔离性：事务在提交前，对其他事务不可见。

持久性：一旦事务提交，所以修改都会永久保存到数据库中。

1.4.2 事务隔离级别

#### 1.5 锁

1.5.1 全局锁、共享锁、排他锁

全局锁：使用场景比如做全库逻辑备份，该命令可以使整个库处于只读状态，阻止一切修改操作。

共享锁（读锁）：其他事务可以并发读取数据，阻止一切修改操作，如果事务对共享锁进行修改，很可能造成死锁。

排它锁（写锁）：某个事务对某行数据加了排它锁，只有该事务能对其进行读和写操作，其他事务不能对其加任和锁。其他进程不能读取，也不能进行写操作。排它锁是悲观锁的一种实现方式。排它锁或阻塞其他的排它锁和共享锁。

1.5.2 死锁

死锁是指两个或者两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象。

如何解决：（1）设置超时时间；（2）发起死锁检测，发现死锁后，主动回滚死锁中的某一个事务，让其他事务继续执行。

1.6 读写分离

核心原理：

![image](./resource/WX20220313-183103@2x.png)

（1）从库连接数主库；
（2）主库异步线程会同步到从库
（3）从库收到数据会启动IO线程写到relay log(中继日志)
（4）从库启动sql线程执行中继日志

1.7 分库分表

水平分表

垂直分表




>>mvcc、锁、事务、主从同步原理、主从延迟 ；事务隔离级别、优化

#### 2. Redis

#### 3. MongoDB

## 五、中间件

#### 1.Kafka